#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""TcEx App Init."""
import argparse
import os
import sys
import traceback

import colorama as c
from tcex.bin import Init

# autoreset colorama
c.init(autoreset=True, strip=False)

epilog = (
    'The "tcinit" command it intended to enable quick development of ThreatConnect Exchange Apps.\n'
    '\nJob App Templates:\n'
    '  job              - This template provides the structure for a Job App without any App\n'
    '                     logic.\n'
    '  job_batch        - This template provides a working example of downloading remote threat \n'
    '                     intel (md5 hash indicators) and writing the data in the ThreatConnect \n'
    '                     Platform using the tcex batch module.\n'
    '\nPlaybook App Templates:\n'
    '  playbook         - This template provides the structure for a Playbook App without any\n'
    '                     App logic.\n'
    '  playbook_actions - This template provides an example of "actions" in a Playbook \n'
    '                     App. Using the "actions" feature a single Playbook App can have \n'
    '                     multiple actions to perform different operations on the provided data.\n'
    '  playbook_utility - This template provides a basic example of a utility App that takes \n'
    '                     an input, analyzes or modifies the data, and writes the results as \n'
    '                     output.\n'
    '\nExternal App Templates:\n'
    '  external         - This template provides the structure for a External App without any\n'
    '                     App logic.\n'
    '  external_ingress - This template provides a working example of downloading remote threat \n'
    '                     intel (md5 hash indicators) and writing the data in the ThreatConnect \n'
    '                     Platform using the tcex batch module.\n'
    '\nService App Templates:\n'
    '  service_api      - This template provides the structure for a API Service App.\n'
    '  service_trigger  - This template provides the structure for a Trigger Service App.\n'
    '  service_webhook  - This template provides the structure for a Webhook Trigger Service App.\n'
)

parser = argparse.ArgumentParser(
    epilog=epilog, formatter_class=argparse.RawDescriptionHelpFormatter
)
parser.add_argument('--branch', default='master', help='Git branch.')
parser.add_argument(
    '--migrate',
    action='store_true',
    help='Enable this flag to migrate an existing App.',
    default=False,
)
parser.add_argument(
    '--update',
    action='store_true',
    help='Enable this flag to update an existing App.',
    default=False,
)
parser.add_argument(
    '--template',
    choices=[
        'external',
        'external_ingress',
        'job',
        'job_batch',
        # 'job_enrichment',
        'playbook',
        'playbook_actions',
        # 'playbook_enrichment',
        'playbook_utility',
        'service_api',
        'service_trigger',
        'service_webhook',
    ],
    help='Choose an appropriate App template for the current project.',
)
args, extra_args = parser.parse_known_args()


if __name__ == '__main__':
    if not args.template and not os.listdir(os.getcwd()) and not args.update:
        print(
            f'{c.Fore.YELLOW}The --template <template type> CLI arg is required when creating a '
            f'new App. If trying to update an existing App please provide the --update CLI flag.'
        )
        sys.exit(1)
    elif not os.listdir(os.getcwd()) and args.update:
        print(f'{c.Fore.YELLOW}The are no files to update. Try removing --update CLI flag.')
        sys.exit(1)

    if os.listdir(os.getcwd()) and not args.update:
        print(
            f'{c.Fore.YELLOW}The current directory does not appear to be empty. Please initialize '
            f'App in an empty directory. If migrating an older App try the --migrate CLI flag or'
            f'if updating an App try the --update CLI flag.'
        )
        sys.exit(1)
    elif os.listdir(os.getcwd()) and not os.getenv('TC_DEVELOPER'):
        print(
            f'{c.Fore.YELLOW}The current directory does not appear to be empty. Updating files '
            f'can cause loss of data. It is STRONGLY recommend you commit/backup all your changes '
            f'before proceeding.'
        )
        message = f'Continue (yes/[no]): '
        response = input(message).strip()
        if response not in ['y', 'yes']:
            sys.exit()

    print(f'{c.Style.BRIGHT}Using files from {c.Fore.CYAN}"{args.branch}"{c.Fore.RESET} branch')

    try:
        tci = Init(args)

        # download common files
        tci.download_template.init_common_files(args.template)

        # download type specific files
        if args.template.startswith('external'):
            tci.download_template.init_external(args.template)
        elif args.template.startswith('job'):
            tci.download_template.init_job()
        elif args.template.startswith('playbook'):
            tci.download_template.init_playbook()
        elif args.template.startswith('service'):
            tci.download_template.init_service(args.template)

        # if we are migrating, update the install.json
        if (args.update or args.migrate) and not args.template.startswith('external'):
            tci.ij.update_schema(migrate=args.migrate)

        if args.update:
            tci.update_tcex_json()

        tci.download_template.print_download_results()
        sys.exit()

    except Exception:
        # TODO: Update this, possibly raise
        print(f'{c.Style.BRIGHT}{c.Fore.RED}{traceback.format_exc()}')
        sys.exit(1)
